<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Voice Cleaner - Local Processing</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', system-ui, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 600px;
            width: 100%;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            text-align: center;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .info-box {
            background: #e7f3ff;
            border-left: 4px solid #667eea;
            padding: 12px;
            margin-bottom: 20px;
            border-radius: 4px;
            font-size: 13px;
            color: #333;
        }

        .upload-section {
            margin-bottom: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            text-align: center;
        }

        .upload-label {
            display: block;
            font-weight: 600;
            color: #555;
            margin-bottom: 12px;
            font-size: 14px;
        }

        .btn-upload {
            background: #f39c12;
            color: white;
            margin: 0 auto;
            display: inline-flex;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-upload:hover:not(:disabled) {
            background: #e67e22;
            transform: translateY(-2px);
        }

        .file-name {
            margin-top: 10px;
            font-size: 13px;
            color: #666;
            font-weight: 500;
            text-align: center;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-record {
            background: #e74c3c;
            color: white;
        }

        .btn-record:hover:not(:disabled) {
            background: #c0392b;
            transform: translateY(-2px);
        }

        .btn-record.recording {
            background: #27ae60;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .btn-stop {
            background: #3498db;
            color: white;
        }

        .btn-stop:hover:not(:disabled) {
            background: #2980b9;
            transform: translateY(-2px);
        }

        .btn-clean {
            background: #9b59b6;
            color: white;
        }

        .btn-clean:hover:not(:disabled) {
            background: #8e44ad;
            transform: translateY(-2px);
        }

        .btn-download {
            background: #16a085;
            color: white;
        }

        .btn-download:hover:not(:disabled) {
            background: #138f75;
            transform: translateY(-2px);
        }

        .audio-section {
            margin-top: 20px;
        }

        .audio-wrapper {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .audio-label {
            font-weight: 600;
            color: #555;
            margin-bottom: 8px;
            display: block;
        }

        audio {
            width: 100%;
            margin-top: 10px;
            border-radius: 5px;
        }

        .status {
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 600;
        }

        .status.recording {
            background: #d4edda;
            color: #155724;
        }

        .status.processing {
            background: #fff3cd;
            color: #856404;
        }

        .status.ready {
            background: #d1ecf1;
            color: #0c5460;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e9ecef;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 8px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s;
        }

        .permission-info {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 12px;
            margin-bottom: 20px;
            border-radius: 4px;
            font-size: 13px;
            color: #856404;
        }

        .supported-formats {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé§ AI Voice Cleaner</h1>
        <p class="subtitle">Record or upload audio for AI-powered noise reduction</p>

        <div class="info-box">
            <strong>100% Local Processing:</strong> All audio processing happens in your browser. No files are uploaded to any server. Your privacy is guaranteed.
        </div>

        <div class="permission-info">
            <strong>‚ö†Ô∏è Permission Required:</strong> Allow microphone access when prompted. This is needed for recording.
        </div>

        <div class="upload-section">
            <label for="fileInput" class="upload-label">
                Upload audio file (MP3, WAV, M4A, OGG, WebM)
            </label>
            <input type="file" id="fileInput" accept=".mp3,.wav,.m4a,.ogg,.webm,audio/*" style="display: none;">
            <button id="uploadBtn" class="btn-upload">
                üìÅ Choose Audio File
            </button>
            <div class="supported-formats">
                Supported: MP3, WAV, M4A, OGG, WebM (max 50MB)
            </div>
            <div id="fileName" class="file-name"></div>
        </div>

        <div id="status" class="status" style="display: none;">
            <div id="statusText"></div>
            <div class="progress-bar" id="progressBar" style="display: none;">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>

        <div class="controls">
            <button id="recordBtn" class="btn-record">
                üé§ Start Recording
            </button>
            <button id="stopBtn" class="btn-stop" disabled>
                ‚èπÔ∏è Stop Recording
            </button>
            <button id="cleanBtn" class="btn-clean" disabled>
                ‚ú® Clean Audio
            </button>
            <button id="downloadBtn" class="btn-download" disabled>
                üíæ Download Cleaned
            </button>
        </div>

        <div class="audio-section">
            <div id="originalAudioSection" style="display: none;" class="audio-wrapper">
                <span class="audio-label">Original Audio</span>
                <audio id="originalAudio" controls></audio>
            </div>

            <div id="cleanedAudioSection" style="display: none;" class="audio-wrapper">
                <span class="audio-label">üéß Cleaned Audio</span>
                <audio id="cleanedAudio" controls></audio>
            </div>
        </div>
    </div>

    <script>
        // Simple state management
        let mediaRecorder = null;
        let audioChunks = [];
        let originalBlob = null;
        let cleanedBlob = null;
        let isRecording = false;
        let stream = null;

        // DOM Elements
        const recordBtn = document.getElementById('recordBtn');
        const stopBtn = document.getElementById('stopBtn');
        const cleanBtn = document.getElementById('cleanBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const uploadBtn = document.getElementById('uploadBtn');
        const fileInput = document.getElementById('fileInput');
        const fileName = document.getElementById('fileName');
        const originalAudio = document.getElementById('originalAudio');
        const cleanedAudio = document.getElementById('cleanedAudio');
        const status = document.getElementById('status');
        const statusText = document.getElementById('statusText');
        const progressBar = document.getElementById('progressBar');
        const progressFill = document.getElementById('progressFill');

        // Status functions
        function showStatus(message, type, showProgress = false) {
            statusText.textContent = message;
            status.className = 'status ' + type;
            status.style.display = 'block';
            progressBar.style.display = showProgress ? 'block' : 'none';
        }

        function updateProgress(percent) {
            progressFill.style.width = percent + '%';
        }

        function hideStatus() {
            status.style.display = 'none';
        }

        // Check browser compatibility
        function checkCompatibility() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                showStatus('Your browser does not support audio recording. Please use Chrome, Firefox, or Edge.', 'error');
                recordBtn.disabled = true;
                return false;
            }
            
            if (!window.MediaRecorder) {
                showStatus('Your browser does not support MediaRecorder API. Please update your browser.', 'error');
                recordBtn.disabled = true;
                return false;
            }
            
            return true;
        }

        // Initialize
        window.addEventListener('DOMContentLoaded', () => {
            checkCompatibility();
            showStatus('Ready to record or upload audio!', 'ready');
        });

        // File upload functionality - FIXED
        uploadBtn.addEventListener('click', () => {
            fileInput.click();
        });

        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            // Check file size (max 50MB)
            if (file.size > 50 * 1024 * 1024) {
                showStatus('File is too large. Please choose a file smaller than 50MB.', 'error');
                return;
            }

            // Check file type
            const validTypes = ['audio/mp3', 'audio/wav', 'audio/mpeg', 'audio/ogg', 'audio/webm', 'audio/m4a', 'audio/x-m4a'];
            if (!validTypes.includes(file.type) && !file.name.match(/\.(mp3|wav|m4a|ogg|webm)$/i)) {
                showStatus('Please select a valid audio file (MP3, WAV, M4A, OGG, or WebM).', 'error');
                return;
            }

            fileName.textContent = `Selected: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`;
            showStatus('Loading file...', 'processing', true);
            updateProgress(30);

            try {
                originalBlob = file;
                const url = URL.createObjectURL(file);
                originalAudio.src = url;
                
                // Ensure audio is loaded
                originalAudio.onloadeddata = () => {
                    document.getElementById('originalAudioSection').style.display = 'block';
                    cleanBtn.disabled = false;
                    updateProgress(100);
                    showStatus('File loaded successfully! Ready to clean.', 'ready', false);
                };
                
                originalAudio.onerror = () => {
                    showStatus('Error loading audio file. Please try a different file.', 'error', false);
                };

            } catch (err) {
                console.error('File loading error:', err);
                showStatus('Error loading file: ' + err.message, 'error', false);
            }
        });

        // Recording functionality - FIXED
        recordBtn.addEventListener('click', async () => {
            if (isRecording) return;
            
            try {
                showStatus('Requesting microphone access...', 'processing');
                
                // Get microphone permission
                stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        sampleRate: 44100,
                        channelCount: 1
                    } 
                });
                
                // Reset chunks
                audioChunks = [];
                
                // Create MediaRecorder with options that work across browsers
                const options = { mimeType: 'audio/webm' };
                
                // Try different mimeTypes for cross-browser compatibility
                if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
                    options.mimeType = 'audio/webm;codecs=opus';
                } else if (MediaRecorder.isTypeSupported('audio/mp4')) {
                    options.mimeType = 'audio/mp4';
                } else if (MediaRecorder.isTypeSupported('audio/ogg')) {
                    options.mimeType = 'audio/ogg;codecs=opus';
                }
                
                mediaRecorder = new MediaRecorder(stream, options);
                
                // Handle data available
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };
                
                // Handle recording stop
                mediaRecorder.onstop = () => {
                    if (audioChunks.length > 0) {
                        originalBlob = new Blob(audioChunks, { type: mediaRecorder.mimeType });
                        const url = URL.createObjectURL(originalBlob);
                        originalAudio.src = url;
                        document.getElementById('originalAudioSection').style.display = 'block';
                        cleanBtn.disabled = false;
                        
                        showStatus('Recording saved! Ready to clean.', 'ready');
                    }
                    
                    // Stop all tracks
                    if (stream) {
                        stream.getTracks().forEach(track => track.stop());
                        stream = null;
                    }
                    
                    isRecording = false;
                };
                
                // Handle errors
                mediaRecorder.onerror = (event) => {
                    console.error('MediaRecorder error:', event.error);
                    showStatus('Recording error: ' + event.error.name, 'error');
                    
                    if (stream) {
                        stream.getTracks().forEach(track => track.stop());
                        stream = null;
                    }
                    
                    isRecording = false;
                    resetRecordingUI();
                };
                
                // Start recording
                mediaRecorder.start(100); // Collect data every 100ms
                isRecording = true;
                
                // Update UI
                recordBtn.classList.add('recording');
                recordBtn.innerHTML = 'üî¥ Recording...';
                recordBtn.disabled = true;
                stopBtn.disabled = false;
                
                showStatus('Recording in progress... Speak into your microphone.', 'recording');
                
            } catch (err) {
                console.error('Recording error:', err);
                
                if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                    showStatus('Microphone access denied. Please allow microphone access in your browser settings.', 'error');
                } else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') {
                    showStatus('No microphone found. Please connect a microphone and try again.', 'error');
                } else if (err.name === 'NotSupportedError') {
                    showStatus('Your browser does not support audio recording.', 'error');
                } else {
                    showStatus('Error accessing microphone: ' + err.message, 'error');
                }
                
                resetRecordingUI();
            }
        });

        // Stop recording
        stopBtn.addEventListener('click', () => {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                resetRecordingUI();
                showStatus('Recording stopped. Processing...', 'processing');
            }
        });

        function resetRecordingUI() {
            isRecording = false;
            recordBtn.classList.remove('recording');
            recordBtn.innerHTML = 'üé§ Start Recording';
            recordBtn.disabled = false;
            stopBtn.disabled = true;
        }

        // Clean audio functionality
        cleanBtn.addEventListener('click', async () => {
            if (!originalBlob) {
                showStatus('Please record or upload audio first.', 'error');
                return;
            }
            
            showStatus('Cleaning audio... This may take a moment.', 'processing', true);
            cleanBtn.disabled = true;
            updateProgress(10);

            try {
                // Create audio context
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                updateProgress(20);
                
                // Convert blob to array buffer
                const arrayBuffer = await originalBlob.arrayBuffer();
                updateProgress(40);
                
                // Decode audio data
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                updateProgress(60);
                
                console.log('Processing audio:', {
                    duration: audioBuffer.duration,
                    sampleRate: audioBuffer.sampleRate,
                    channels: audioBuffer.numberOfChannels
                });
                
                // Process audio (simplified - you can add your processing logic here)
                const cleanedBuffer = await processAudio(audioBuffer, audioContext);
                updateProgress(80);
                
                // Convert to WAV
                cleanedBlob = bufferToWave(cleanedBuffer);
                const url = URL.createObjectURL(cleanedBlob);
                cleanedAudio.src = url;
                document.getElementById('cleanedAudioSection').style.display = 'block';
                downloadBtn.disabled = false;
                
                updateProgress(100);
                showStatus('Audio cleaned successfully!', 'ready', false);
                
                // Close audio context
                await audioContext.close();
                
            } catch (err) {
                console.error('Cleaning error:', err);
                showStatus('Error cleaning audio: ' + err.message, 'error');
                cleanBtn.disabled = false;
            }
        });

        // Audio processing function
        async function processAudio(audioBuffer, audioContext) {
            // Create offline context for processing
            const offlineContext = new OfflineAudioContext(
                audioBuffer.numberOfChannels,
                audioBuffer.length,
                audioBuffer.sampleRate
            );
            
            // Create buffer source
            const source = offlineContext.createBufferSource();
            source.buffer = audioBuffer;
            
            // Apply noise reduction filters
            const filters = createNoiseReductionChain(offlineContext);
            
            // Connect processing chain
            source.connect(filters.input);
            filters.output.connect(offlineContext.destination);
            
            // Start processing
            source.start(0);
            
            // Render processed audio
            const renderedBuffer = await offlineContext.startRendering();
            
            return renderedBuffer;
        }

        // Create noise reduction filter chain
        function createNoiseReductionChain(context) {
            const input = context.createGain();
            const output = context.createGain();
            
            // 1. High-pass filter to remove low-frequency rumble
            const highPass = context.createBiquadFilter();
            highPass.type = 'highpass';
            highPass.frequency.value = 100;
            highPass.Q.value = 0.707;
            
            // 2. Low-pass filter to remove high-frequency noise
            const lowPass = context.createBiquadFilter();
            lowPass.type = 'lowpass';
            lowPass.frequency.value = 5000;
            lowPass.Q.value = 0.707;
            
            // 3. Notch filter for 50/60Hz hum
            const notch60 = context.createBiquadFilter();
            notch60.type = 'notch';
            notch60.frequency.value = 60;
            notch60.Q.value = 20;
            
            const notch50 = context.createBiquadFilter();
            notch50.type = 'notch';
            notch50.frequency.value = 50;
            notch50.Q.value = 20;
            
            // 4. Voice presence boost
            const presence = context.createBiquadFilter();
            presence.type = 'peaking';
            presence.frequency.value = 2000;
            presence.Q.value = 1.0;
            presence.gain.value = 6;
            
            // 5. Compressor for dynamic range
            const compressor = context.createDynamicsCompressor();
            compressor.threshold.value = -30;
            compressor.knee.value = 20;
            compressor.ratio.value = 4;
            compressor.attack.value = 0.005;
            compressor.release.value = 0.1;
            
            // Connect the chain
            input.connect(notch60);
            notch60.connect(notch50);
            notch50.connect(highPass);
            highPass.connect(lowPass);
            lowPass.connect(presence);
            presence.connect(compressor);
            compressor.connect(output);
            
            return { input, output };
        }

        // Download functionality
        downloadBtn.addEventListener('click', () => {
            if (!cleanedBlob) return;
            
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const url = URL.createObjectURL(cleanedBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `cleaned-audio-${timestamp}.wav`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showStatus('Download started!', 'ready');
        });

        // Convert audio buffer to WAV format
        function bufferToWave(abuffer) {
            const numOfChan = abuffer.numberOfChannels;
            const length = abuffer.length * numOfChan * 2;
            const buffer = new ArrayBuffer(44 + length);
            const view = new DataView(buffer);
            
            // Write WAV header
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + length, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numOfChan, true);
            view.setUint32(24, abuffer.sampleRate, true);
            view.setUint32(28, abuffer.sampleRate * 2 * numOfChan, true);
            view.setUint16(32, numOfChan * 2, true);
            view.setUint16(34, 16, true);
            writeString(view, 36, 'data');
            view.setUint32(40, length, true);
            
            // Write PCM data
            let offset = 44;
            for (let i = 0; i < abuffer.length; i++) {
                for (let chan = 0; chan < numOfChan; chan++) {
                    const sample = Math.max(-1, Math.min(1, abuffer.getChannelData(chan)[i]));
                    view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                    offset += 2;
                }
            }
            
            return new Blob([buffer], { type: 'audio/wav' });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
            
            // Revoke object URLs
            if (originalAudio.src) URL.revokeObjectURL(originalAudio.src);
            if (cleanedAudio.src) URL.revokeObjectURL(cleanedAudio.src);
        });
    </script>
</body>
</html>
